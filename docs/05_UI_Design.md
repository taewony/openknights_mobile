# UI/UX 디자인 및 구현 가이드

이 문서는 OpenKnights 앱의 화면을 디자인하고 구현하는 전체적인 프로세스를 안내하기 위해 작성되었습니다. 일관성 있는 사용자 경험을 제공하고, 효율적으로 개발하기 위한 가이드라인을 제시합니다.

---

## 화면 디자인 순서

*(이곳에 사용자께서 제공해주실 '화면 디자인 순서'에 대한 내용을 추가할 예정입니다.)*

---

## 화면 구현 프로세스 예시: 'Contest' 기능

새로운 기능을 기획하고 화면에 구현하는 전체적인 프로세스를 'Contest(대회)' 기능 개발을 예시로 알아봅시다. 이 프로세스는 우리가 정의한 아키텍처를 어떻게 실제로 적용하는지 보여주는 좋은 예시가 될 것입니다.

### Phase 1: 데이터 계층 설정 (in `:core:data`)

가장 먼저 UI에 보여줄 데이터가 무엇인지 정의하고, 그 데이터를 가져올 방법을 준비합니다.

1.  **`ContestRepository` 인터페이스 정의:**
    *   `Contest` 데이터를 처리하는 함수의 명세를 설계합니다. 예를 들어 `getContests()` 라는 함수를 정의하여 "대회 목록을 가져온다"는 기능을 약속합니다.

2.  **`ContestRepositoryImpl` 구현체 생성:**
    *   `ContestRepository` 인터페이스의 실제 동작을 구현합니다.
    *   초기 개발 단계에서는 UI 팀이 실제 데이터 없이도 화면을 만들 수 있도록, **가짜(Fake) 데이터**를 반환하는 코드를 작성합니다.
    *   *추후 이 부분은 Firebase Firestore와 통신하여 실제 데이터를 가져오는 코드로 변경됩니다.*

### Phase 2: 기능/UI 계층 설정 (in `:feature`)

데이터가 준비되었으니, 이제 사용자가 볼 화면과 화면의 상태를 관리하는 로직을 만듭니다.

1.  **`contest` 패키지 생성:**
    *   `:feature` 모듈의 `com.openknights.feature` 패키지 내부에 `contest` 라는 새로운 패키지를 만들어 관련 파일들을 그룹화합니다.

2.  **`ContestViewModel` 생성:**
    *   화면의 상태(로딩 중, 성공, 실패 등)를 관리하고, 데이터 계층(`ContestRepository`)과 통신하는 `ViewModel`을 만듭니다.
    *   `loadContests()` 같은 함수를 통해 Repository에게 데이터를 요청하고, 그 결과를 `ContestUiState`에 담아 UI가 사용할 수 있도록 노출합니다.

3.  **`ContestScreen` 생성:**
    *   `ContestViewModel`이 제공하는 상태(`UiState`)를 보고 실제 화면을 그리는 Composable 함수입니다.
    *   사용자가 "새로고침" 버튼을 누르면 `ViewModel`의 `loadContests()` 함수를 호출하도록 연결합니다.

4.  **`ContestList` 및 `ContestCard` 생성:**
    *   데이터 로딩에 성공했을 때, 대회 목록 전체를 보여주는 `ContestList`와 목록의 각 항목 하나하나를 보여주는 `ContestCard`를 만들어 화면을 완성합니다.

### Phase 3: 화면 연결 (in `:app`)

마지막으로, 완성된 화면을 사용자가 접근할 수 있도록 앱의 전체 구조에 연결합니다.

1.  **Navigation 설정:**
    *   앱의 메인 네비게이션(예: 하단 탭 바)에 '대회' 탭을 추가하고, 이 탭을 눌렀을 때 우리가 만든 `ContestScreen`이 나타나도록 경로를 설정합니다.
